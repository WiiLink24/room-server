import requests
import json
import errno
import logging
import os
import requests
import sentry_sdk
import struct
import subprocess
import codecs
from datadog import initialize, api, statsd
from urllib.parse import urljoin
from base64 import standard_b64encode, b64encode
from __future__ import unicode_literals
from functools import partialmethod
from printful._compat import urllib, force_text, force_bytes
from sentry_sdk.integrations.logging import LoggingIntegration
from base64 import b64encode

class PrintfulException(Exception):
    """ Used for response JSON validation """


class PrintfulAPIException(Exception):
    """ Invalid API Server Responses
    """
    def __init__(self, resp):
        self.code = resp['code']
        self.result = resp['result']

    def __str__(self):
        return 'Server Response {0}: {1}'.format(self.code,
                                          self.result)


class Printful:

    def __init__(self, key):
        """
        This is the main client that handles all of the requests
        to the Printful API.  The class uses [requests](http://docs.python-requests.org/en/latest/)
        as a way to interact with the server.

        :param key: API key generated by Printful

        Usage::

            >>> import printful
            >>> pf = printful.Printful(key)
            >>> orders = pf.get('orders')

        """
        self.key = bytearray(key, 'utf-8')
        self.api_url = 'https://api.theprintful.com/'
        self.user_agent = 'Printful API Python Library 1.2'
        self._response = {}

    @property
    def request_headers(self):
        return {'Authorization': 'Basic {0}'.format(self._auth()),
                'User-Agent': self.user_agent,
                'Content-Type': 'application/json'}

    @property
    def response(self):
        return self._response

    @response.setter
    def response(self, val):
        try:
            resp = self._to_dict(val)
        except ValueError:
            raise PrintfulException('API response was not valid JSON.')
        self._response = resp

    def _request(self, method, path, **params):
        params.update(verify=True, headers=self.request_headers)
        url = urljoin(self.api_url, path)
        r = requests.request(method, url, **params)
        if r.status_code not in range(200, 301):
            raise PrintfulAPIException(self._to_dict(r.json()))
        self.response = r.json()
        return self.response

    def _auth(self):
        return standard_b64encode(self.key).decode('ascii')

    def _http_method(self, method, path, **params):
        return self._request(method, path, **params)

    def _to_dict(self, json_obj):
        return json.loads(json.dumps(json_obj))

    get = partialmethod(_http_method, 'GET')
    post = partialmethod(_http_method, 'POST')
    put = partialmethod(_http_method, 'PUT')
    delete = partialmethod(_http_method, 'DELETE')


    def item_count(self):
        """
        Get the number of items returned in the last response.
        Helpful for result sets that may require paginated requests.
        :return: int

        """
        if self.response:
            try:
                return self.response['paging'].get('total', None)
            except KeyError:
                raise PrintfulException('API response did not contain paginated results.')
        return None

requests.packages.urllib3.disable_warnings()  # This is so we don't get some warning about SSL.

production = False
p_errors = False

def setup_log(sentry_url, print_errors):
    global logger, production
    sentry_logging = LoggingIntegration(
        level=logging.INFO,
        event_level=logging.INFO
    )
    sentry_sdk.init(dsn=sentry_url, integrations=[sentry_logging])
    logger = logging.getLogger(__name__)
    p_errors = print_errors
    production = True

def log(msg, level):  # TODO: Use number levels, strings are annoying
    if p_errors:
        print(msg)

    if production:
        if level == "VERBOSE":
            logger.debug(msg)
        elif level == "INFO":
            logger.info(msg)
        elif level == "WARNING":
            logger.warning(msg)
        elif level == "CRITICAL":
            logger.critical(msg)

def mkdir_p(path):
    try:
        os.makedirs(path)
    except:
        pass


"""Pack integers to specific type."""

# Unsigned integers

def u8(data):
    if not 0 <= data <= 255:
        log("u8 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">B", data)


def u16(data):
    if not 0 <= data <= 65535:
        log("u16 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">H", data)


def u32(data):
    if not 0 <= data <= 4294967295:
        log("u32 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">I", data)


def u32_littleendian(data):
    if not 0 <= data <= 4294967295:
        log("u32 little endian out of range: %s" % data, "INFO")
        data = 0
    return struct.pack("<I", data)

# Signed integer

def s8(data):
    if not -128 <= data <= 127:
        log("s8 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">b", data)


def s16(data):
    if not -32768 <= data <= 32767:
        log("s16 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">h", data)


def s32(data):
    if not -2147483648 <= data <= 2147483647:
        log("s32 out of range: %s" % data, "INFO")
        data = 0
    return struct.pack(">i", data)

def senddatadoglogs(production, sender, options, data):
    initialize(**options)
    api.Event.create(data=data)
def statisticssender(logphp, method, phpname):
    data = method + logphp + phpname
    proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE)
    script_response = proc.stdout.read()
def configpathreturner(filenamemain):
    datamain = open(filenamemain)
    linesmain = datamain.readlines()
    datamain.close()
    return linesmain;
def rbdata(filenamesecn):
    datasecn = open(filenamesecn)
    linessecn = datasecn.readlines()
    datasecn.close()
    return linessecn;
def dynamicmain(scriptidmain)
    scriptidsecn = scriptidmain + 1
    scriptidothr = scriptidmain + 2
    datamain = "./readtables.sh"
    datasecn = " -a "
    dataothr = datamain + datasecn + scriptidmain
    datarest = datamain + datasecn + scriptidsecn
    datamore = datamain + datasecn + scriptidothr
    subprocessmain = subprocess.Popen(dataothr, shell=True, stdout=subprocess.PIPE)
    scriptidrest = subprocessmain.stdout.read()
    subprocesssecn = subprocess.Popen(datarest, shell=True, stdout=subprocess.PIPE)
    scriptidmore = subprocesssecn.stdout.read()
    subprocessothr = subprocess.Popen(datamore, shell=True, stdout=subprocess.PIPE)
    scriptidsome = subprocessothr.stdout.read()
    return scriptidrest;
def dynamicsecn(scriptidsecn)
    scriptidrest = scriptidsecn + 1
    scriptidothr = scriptidsecn + 2
    datamain = "./readtables.sh"
    datasecn = " -a "
    dataothr = datamain + datasecn + scriptidsecn
    datarest = datamain + datasecn + scriptidrest
    datamore = datamain + datasecn + scriptidothr
    subprocessmain = subprocess.Popen(dataothr, shell=True, stdout=subprocess.PIPE)
    scriptidrest = subprocessmain.stdout.read()
    subprocesssecn = subprocess.Popen(datarest, shell=True, stdout=subprocess.PIPE)
    scriptidmore = subprocesssecn.stdout.read()
    subprocessothr = subprocess.Popen(datamore, shell=True, stdout=subprocess.PIPE)
    scriptidsome = subprocessothr.stdout.read()
    return scriptidmore;
def dynamicothr(scriptidsecn)
    scriptidrest = scriptidsecn + 1
    scriptidothr = scriptidsecn + 2
    datamain = "./readtables.sh"
    datasecn = " -a "
    dataothr = datamain + datasecn + scriptidsecn
    datarest = datamain + datasecn + scriptidrest
    datamore = datamain + datasecn + scriptidothr
    subprocessmain = subprocess.Popen(dataothr, shell=True, stdout=subprocess.PIPE)
    scriptidrest = subprocessmain.stdout.read()
    subprocesssecn = subprocess.Popen(datarest, shell=True, stdout=subprocess.PIPE)
    scriptidmore = subprocesssecn.stdout.read()
    subprocessothr = subprocess.Popen(datamore, shell=True, stdout=subprocess.PIPE)
    scriptidsome = subprocessothr.stdout.read()
    return scriptidsome;
def datareturner(currentpath)
    datamain = "sh "
    datasecn = "readbackid.sh"
    dataothr = datamain + currentpath + datasecn
    subprocess = subprocess.Popen(dataothr, shell=True, stdout=subprocess.PIPE)
    subprocess_return = subprocess.stdout.read()
    return subprocess_return;

class PrintfulException(Exception):
    pass


class PrintfulApiException(PrintfulException):
    def __init__(self, message, code):
        super(PrintfulApiException, self).__init__(message, code)
        Exception.__init__(self, message)
        self.code = code

    def __str__(self):
        return '%i - %s' % (self.code, self.message)


class Response(object):

    def __init__(self, data):
        self.data = data

    def item_count(self):
        if (self.data and u'paging' in self.data):
            return self.data['paging']['total']
        else:
            return None


class HTTPBasicKeyAuth(requests.auth.AuthBase):
    def __init__(self, key):
        self.key = force_bytes(key, 'utf-8')

    def __call__(self, request):
        auth = 'Basic ' + force_text(b64encode(self.key))
        request.headers['Authorization'] = auth

        return request


class Client(requests.Session):
    API_URL = 'https://api.theprintful.com/'
    USER_AGENT = 'Printful API Python Library 1.0'

    def __init__(self, api_key):
        super(Client, self).__init__()
        self.api_key = api_key

    def request(self, method, url, *args, **kwargs):
        headers = {
            'User-Agent': Client.USER_AGENT,
            'Content-Type': 'application/json',
            'Method': method,
        }

        headers.update(kwargs.pop('headers', {}))

        kwargs.update({
            'auth': HTTPBasicKeyAuth(self.api_key),
            'headers': headers,
        })

        full_url = urllib.parse.urljoin(Client.API_URL, url).rstrip('/')

        # TODO: Error handling
        return super(Client, self).request(method, full_url, *args, **kwargs)
def get_fixture(name):
    filename = os.path.join(os.path.dirname(__file__), 'fixtures', name)
    with codecs.open(filename, encoding='utf-8') as fp:
        return fp.read()
def zero():
    zero = 0
    return zero
def one():
    one = 1
    return one
